<!doctype html>

  <html lang="en">
  <head>
    <meta charset="utf-8">

    <script src="open-in-.js"></script>
    <script src="copy-snippet.js"></script>
    <script src="console-assert.js"></script>

  </head>

  <body>

    <h2>Event Loop Exercises </h2>
    <div>
      the smoothest workflow for these exercises will either be either:
      <ul>
        <li>
          edit this file in your text editor and check your solutions in the browser
        </li>
        <li>
          write your solutions <a href="https://janke-learning.org/louping" target="_blank">here</a> and paste them into this file
        </li>
      </ul>
    </div>

    <hr>
    <hr>

    <div id="exercise-1">
      <h3> exercise 1</h3>
      <p>
        all mixed up
      </p>
      <script id="solution-1">
{ // replace the "null"s with a number of milliseconds
  let x = "";

  setTimeout(function assert_a() {
      console.assert(x === "javascript", "exercise 1", "a");
  }, null);

  setTimeout(function append_lastname() {
      x += "script";
  }, null);

  setTimeout(function assert_b() {
      console.assert(x === "java", "exercise 1", "b");
  }, null);

  setTimeout(function append_firstname() {
      x += "java";
  }, null);

  setTimeout(function assert_c() {
      console.assert(x === "", "exercise 1", "c");
  }, null);

}
      </script>
      <button onclick="copy_code('solution-1')">run in console</button>
      <button onclick="open_in_loupe('solution-1')">run in loupe</button>
      <button onclick="open_in_louping('solution-1')">edit in louping</button>
    </div>

    <hr>

    <div id="exercise-2">
      <h3>exercise 2</h3>
      <p> 
        values on arrival or on departure?
      </p>
      <script id="solution-2">
{ // replace the "null"s in the asserts
  let x = "";

  setTimeout(function assert_a() {
      console.assert(x === null, "exercise 2", "a");
  }, 500);

  x = "second value";

  setTimeout(function assert_b() {
      console.assert(x === null, "exercise 2", "b");
  }, 500);

  x = "third value";

  setTimeout(function assert_c() {
      console.assert(x === null, "exercise 2", "c");
  }, 500);

  x = "final value";

  // do the assert functions get their value from closure or from scope?
}
      </script>
      <button onclick="copy_code('solution-2')">run in console</button>
      <button onclick="open_in_loupe('solution-2')">run in loupe</button>
      <button onclick="open_in_louping('solution-2')">edit in louping</button>
    </div>
    
    <hr>

    <div id="exercise-3">
      <h3>exercise 3</h3>
      <p> 
        arguments to callbacks
      </p>
      <script id="solution-3">
{ // replace the "null"s in the asserts
  let x = "";

  setTimeout(function assert_a(y) {
      console.assert(y === null, "exercise 3", "a");
  }, 500, x);

  x = "second";

  setTimeout(function assert_b(y, z) {
      console.assert(y+z === null, "exercise 3", "b");
  }, 500, x, 3);

  x = "third";

  setTimeout(function assert_c(y, z) {
      console.assert(y+z === null, "exercise 3", "c");
  }, 500, x, x);

  x = "fourth";

  setTimeout(function assert_d(y, z) {
      console.assert(x+y+z === null, "exercise 3", "d");
  }, 500, x, x);

  x = "final";

  // do the assert functions get their value from closure or from scope?
}
      </script>
      <button onclick="copy_code('solution-3')">run in console</button>
      <button onclick="open_in_loupe('solution-3')">run in loupe</button>
      <button onclick="open_in_louping('solution-3')">edit in louping</button>
    </div>
    
    <hr>


    <div id="exercise-4">
      <h3>exercise 4</h3>
      <p>
        <a href="https://github.com/elewa-academy/callbacks" target="_blank">error first callbacks</a>
      </p>
      <script id="solution-4">
{
  // do what the callbacks say
  setTimeout(function(err, msg) {
    if (err) {
      // throw the error to prevent reaching the false assert
      console.assert(false, "exercise 4", "a"); // don't change this line
    } else {
      console.assert(true, "exercise 4", "a");
    }
  }, 0, new Error("handle me!"), "ignore me");


  setTimeout(function(err, msg) {
    if (true) { // put one of the arguments in the condition to pass
      console.assert(false, "exercise 4", "b");
    } else {
      console.assert(true, "exercise 4", "b");
    }
  }, 0, null, "ignore me");


  setTimeout(function() { // add arguments to avoid the false assert
    if (err) {
      console.assert(true, "exercise 4", "c");
    } else {
      console.assert(false, "exercise 4", "c");
    }
  }, 0, "", new Error("handle me!"));


  setTimeout(function(err, msg) { 
    if (err) {
      console.assert(false, "exercise 4", "d");
    } else {
      console.assert(true, "exercise 4", "d");
    }
  }, 0, true, true); // fix these arguments to reach the false assert


  setTimeout(function(err, msg) { 
    if (err) {
      throw err;
      console.assert(false, "exercise 4", "d");
    } else {
      console.assert(false, "exercise 4", "d");
    }
  }, 0, ); // define arguments to avoid the false assert
}
      </script>
      <button onclick="copy_code('solution-4')">run in console</button>
      <button onclick="open_in_loupe('solution-4')">run in loupe</button>
      <button onclick="open_in_louping('solution-4')">edit in louping</button>
    </div>

    <hr>

    <div id="exercise-5">
      <h3>exercise 5</h3>
      <p> 
        arguments to callbacks & modifying global variables
      </p>
      <script id="solution-5">
{ // replace the "null"s in the asserts
  let x = "";

  setTimeout(function assert_a(y) {
      console.assert(y === null, "exercise 5", "a");
      x = "assert a";
  }, 100, x);

  x = "second";

  setTimeout(function assert_b(y, z) {
      x = "assert b";
      console.assert(y+z === null, "exercise 5", "b");
  }, 500, x, 5);

  x = "third";

  setTimeout(function assert_c(y, z) {
      console.assert(y+z === null, "exercise 5", "c");
  }, 200, x, x);

  x = "fourth";

  setTimeout(function assert_d(y, z) {
      console.assert(x+y+z === null, "exercise 5", "d");
      x = "assert d";
  }, 300, x, x);

  x = "final";

  // do the assert functions get their value from closure or from scope?
}
      </script>
      <button onclick="copy_code('solution-5')">run in console</button>
      <button onclick="open_in_loupe('solution-5')">run in loupe</button>
      <button onclick="open_in_louping('solution-5')">edit in louping</button>
    </div>
    
    <hr>


    <div id="exercise-6">
      <h3>exercise 6</h3>
      <p>
        <a href="https://github.com/janke-learning/reference-vs-value" target="_blank">reference vs. value</a> in the event loop
      </p>
      <script id="solution-6">
{ // set the "null"s to values to pass the asserts

  let by_value = "val: first";

  setTimeout(function a_assert() {
    console.assert(by_value === null, "exercise 6", "a");
  }, 0);

  setTimeout(function b_assert(x) {
    console.assert(x === null, "exercise 6", "b");
  }, 0, by_value);

  by_value = "val: second";

  
  let by_ref = {prop: "ref: first"};

  setTimeout(function c_assert() {
    console.assert(by_ref.prop === null, "exercise 6", "c");
  }, 0);

  setTimeout(function d_assert(x) {
    console.assert(x === null, "exercise 6", "d");
  }, 0, by_ref.prop);

  setTimeout(function e_assert(x) {
    console.assert(x.prop === null, "exercise 6", "e");
  }, 0, by_ref);

  by_ref.prop = "ref: second";

}
      </script>
      <button onclick="copy_code('solution-6')">run in console</button>
      <button onclick="open_in_loupe('solution-6')">run in loupe</button>
      <button onclick="open_in_louping('solution-6')">edit in louping</button>
    </div>

    <hr>

    <div id="exercise-7">
      <h3>exercise 7</h3>
      <p>
        <a href="https://github.com/janke-learning/reference-vs-value" target="_blank">reference vs. value</a> in the event loop
      </p>
      <script id="solution-7">
{ // set the "null"s to values to pass the asserts

  let by_value = "val: first";

  setTimeout(function a_change() {
    by_value = "a change";
  }, 0);
  setTimeout(function a_assert() {
    console.assert(by_value === null, "exercise 7", "a");
  }, 1);

  setTimeout(function b_change(x) {
    x = "b change";
  }, 2, by_value);
  setTimeout(function b_assert(x) {
    console.assert(x === null, "exercise 7", "b");
  }, 4, by_value);

  by_value = "val: second";

  
  let by_ref = {prop: "ref: first"};

  setTimeout(function c_change() {
    by_ref.prop = "c change";
  }, 0);
  setTimeout(function c_assert() {
    console.assert(by_ref.prop === null, "exercise 7", "c");
  }, 1);

  setTimeout(function d_change(x) {
    x = "d change";
  }, 2, by_ref.prop);
  setTimeout(function d_assert(x) {
    console.assert(x === null, "exercise 7", "d");
  }, 3, by_ref.prop);

  setTimeout(function e_change(x) {
    x.prop = "e change";
  }, 4, by_ref);
  setTimeout(function e_assert(x) {
    console.assert(x.prop === null, "exercise 7", "e");
  }, 5, by_ref);

  by_ref.prop = "ref: second";

}
      </script>
      <button onclick="copy_code('solution-7')">run in console</button>
      <button onclick="open_in_loupe('solution-7')">run in loupe</button>
      <button onclick="open_in_louping('solution-7')">edit in louping</button>
    </div>

    <hr>


    <div id="exercise-8">
      <h3>exercise 8</h3>
      <p> 
        var, let, const in for loops <br>
        this is tricky, check it <a href="http://www.pythontutor.com/live.html#code=/*%20this%20simulates%20what%20happens%20to%20var%20loops%20in%20Loupe%0Awhen%20the%20setTimeout%20comes%20back%20to%20the%20stack,%0Athe%20loop%20is%20already%20finished%20and%20%22i%22%20is%203.%0ABecause%20there%20is%20only%20one%20%22i%22,%0Aso%20all%203%20callbacks%20will%20access%20and%20push%20the%20same%20value%0A*/%0Aconst%20var_guess%20%3D%20%5Bnull,%20null,%20null%5D%3B%0Aconst%20var_actual%20%3D%20%5B%5D%3B%0Afor%20%28var%20i%20%3D%200%3B%20i%20%3C%203%3B%20i%2B%2B%29%20%7B%0A%7D%0Avar_actual.push%28i,%20i,%20i%29%3B%0A%0A/*%20watch%20carefully%20how%20the%20block%20scopes%20behave%20%0Athe%20animation%20on%20the%20right%20has%20a%20SECOND%20block%20created%0Awith%20a%20new%20value%20and%20deleted%20every%20time%20the%20loop%20is%20executed.%0AThis%20is%20designed%20to%20avoid%20what%20happens%20in%20the%20loop%20above.%20%0AEach%20setTimeout%20is%20given%20it's%20own%20personal%20copy%20of%20%22i%22%20%0AThe%20loop%20iterating%20%22i%22%20doesn't%20effect%20the%20exiting%20callbacks%0A*/%0Aconst%20let_guess%20%3D%20%5Bnull,%20null,%20null%5D%3B%0Aconst%20let_actual%20%3D%20%5B%5D%3B%0Afor%20%28let%20i%20%3D%200%3B%20i%20%3C%203%3B%20i%2B%2B%29%20%7B%0A%20%20let_actual.push%28i%29%3B%0A%7D%0A%0A//%20const%20throws%20an%20error%20when%20you%20try%20to%20modify%20it%0Aconst%20const_guess%20%3D%20%5Bnull,%20null,%20null%5D%3B%0Aconst%20const_actual%20%3D%20%5B%5D%3B%0Afor%20%28const%20i%20%3D%200%3B%20i%20%3C%203%3B%20i%2B%2B%29%20%7B%0A%20%20const_actual.push%28i%29%3B%0A%7D&cumulative=false&curInstr=0&heapPrimitives=nevernest&mode=display&origin=opt-live.js&py=js&rawInputLstJSON=%5B%5D&textReferences=false" target="_blank"> on pytut</a>
      </p>
      <script id="solution-8">
{ // replace the "null"s in the guess arrays to pass the asserts
  const var_guess = [null, null, null];

  for (var i = 0; i < 3; i++) {
    setTimeout(function var_assert() {
      console.assert(i === var_guess[i], "exercise 8", "var");
    }, 600);
  }


  const let_guess = [null, null, null];

  for (let i = 0; i < 3; i++) {
    setTimeout(function let_assert() {
      console.assert(i === let_guess[i], "exercise 8", "let");
    }, 600);
  }


  const const_guess = [null, null, null];

  for (const i = 0; i < 3; i++) {
    console.log(i)
    setTimeout(function const_assert() {
      console.assert(i === const_guess[i], "exercise 8", "const");
    }, 600);
  }

}
      </script>
      <button onclick="copy_code('solution-8')">run in console</button>
      <button onclick="open_in_loupe('solution-8')">run in loupe</button>
      <button onclick="open_in_louping('solution-8')">edit in louping</button>
    </div>
    
  
    <hr>

  </body>

</html>